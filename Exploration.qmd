---
title: "Exploration"
editor: visual
bibliography: references.bib
execute:
  # show code chunk output
  include: true
  # Show the code in the output
  echo: false
  # Show warnings
  warning: true
  # Cache code results
  cache: true
  message: false
format: 
  html:
    toc: true
    code-fold: true
    embed-resources: true
---

## Paracou 6

Fonctions pour l'ajustement de la RAC en logsérie, copié de `calcul_alpha.qmd`, tests retirés.

```{r}
#| label: fit-alpha
# Theoretical rank of abundances
lseries_RAC <- function(abd, alpha) {
  rank <- vapply(
    abd, 
    function(x) {
      n <- x * log(1 + alpha / sum(abd))
      f <- stats::integrate(function(t) {exp(-t) / t}, lower = n, upper = Inf)
      fv <- f[["value"]]
      return(alpha * fv)
    }, 
    FUN.VALUE = 0
  )
  tibble(rank, abundance = abd) |>
    arrange(rank)
}

# Fit alpha by minimizing the departure of species ranks from their theoretical value in a logseries
fit_alpha <- function(abd) {
  abd_decr <- sort(abd[abd > 0], decreasing = TRUE)
  optimized <- optim(
    par = vegan::fisher.alpha(abd),
    fn = function(alpha) {
      sum(abs(seq_along(abd_decr) - lseries_RAC(abd_decr, alpha)$rank))
    }, 
    method = "L-BFGS-B",
    lower = 0
  )
  optimized$par
}
```

Estimation d'alpha à Paracou.

```{r}
library("tidyverse")
library("vegan")
library("divent")
paracou_6_abd %>% 
  metacommunity() %>% 
  {. ->> paracou_6_mc} %>% 
  as.numeric() %>% 
  fit_alpha() %>% 
  print() ->
  paracou_6_alpha
```

Distribution de Paracou

```{r}
# Points d'estimation de la SAC
levels <- c(1:500, 500 + (1:50) * 10, 1000 + (1:50) * 100, 6000 + (1:15) * 1000)
# SAC
paracou_6_mc %>% 
  accum_hill(levels = levels[levels <= abd_sum(., as_numeric = TRUE)]) %>% 
  autoplot() +
  scale_x_log10() +
  # Courbe d'accumulation d'une log-série
  geom_function(fun = \(n) {paracou_6_alpha * log(1 + n / paracou_6_alpha)}, col = "black")
```

## Log-séries

```{r}
rcommunity(1, size = 1E6, distribution = "lseries") -> lseries_c
lseries_c  %>% 
  accum_hill(levels = levels) ->
accum_lseries
accum_lseries %>% 
  autoplot() +
  scale_x_log10()
```

## Sous-échantillonnage

```{r}
size <- 1E4
rmultinom(
  1, 
  size = size, 
  prob = as.numeric(as_probabilities(lseries_c))
) %>% 
  t() %>% 
  as_abundances() %>% 
  accum_hill(levels = levels[levels <= abd_sum(., as_numeric = TRUE)]) %>% 
  autoplot() +
  scale_x_log10()
```

## Régional

```{r}
k <- 1000
z <- 1/8
ggplot(data.frame(x = 1:1000), aes(x)) +
  geom_function(fun = \(x) k * x^z) +
  scale_x_log10()
```

## Guyane

```{r}
"data/abundances.csv" %>% 
  read_csv2() %>% 
  select(-1) %>% 
  as.matrix() ->
  gf_abd
gf_abd %>% 
  as_abundances() %>% 
  mutate(weight = 1) %>% 
  metacommunity() ->
  gf_mc

gf_mc %>% 
  accum_hill(levels = levels[levels <= abd_sum(., as_numeric = TRUE)]) %>% 
  autoplot() ->
  gf_sar

# logseries
gf_sar + scale_x_log10()
# alpha
gf_mc %>% 
  fisher.alpha() %>% 
  print() -> 
  gf_alpha
# Richness
gf_n <- 5E9
gf_alpha * log(1 + gf_n / gf_alpha)
```

Sous-échantillonnage

```{r}
alpha_sub <- function(sample_size, abd) {
  the_sample <- sample(seq_len(nrow(abd)), size = sample_size) 
  abd[the_sample, ] %>% 
    as_abundances() %>% 
    mutate(weight = 1) %>% 
    metacommunity() %>% 
    fisher.alpha()
}

sizes <- seq_len(nrow(gf_abd))
alphas <- sapply(sizes, FUN = alpha_sub, abd = gf_abd)
tibble(NbPlots = sizes, alpha = alphas) %>% 
  ggplot(aes(x = NbPlots, y = alpha)) +
  geom_line() +
  scale_x_log10() +
  geom_smooth(method = "lm")
```

Un point par plot

```{r}
# Select one plot per location...
"data/plots.csv" %>% 
  read_csv2() %>% 
  # Set a random value to each plot
  mutate(random = runif(n())) -> 
  plots_randomized
plots_randomized %>% 
  group_by(Location) %>%
  # Select the plot with the max random value in each location
  summarize(random_max = max(random)) %>% 
  rename(random = random_max) %>% 
  # Eliminate non-selected plots
  inner_join(plots_randomized) %>% 
  select(Plot) -> 
  plots_selected
"data/abundances.csv" %>% 
  read_csv2() %>% 
  # Selected plots only
  inner_join(plots_selected) %>% 
  rename(site = Plot) %>% 
  as_abundances() %>% 
  mutate(weight = 1) -> 
  gf_sub_abd
gf_sub_abd %>% 
  metacommunity() %>% 
  fisher.alpha()
# Sous-échantillonnage
sizes <- seq_len(nrow(gf_sub_abd))
alphas <- sapply(sizes, FUN = alpha_sub, abd = gf_sub_abd)
tibble(NbPlots = sizes, alpha = alphas) %>% 
  ggplot(aes(x = NbPlots, y = alpha)) +
  geom_line() +
  scale_x_log10() +
  geom_smooth(method = "lm") +
  ggpubr::stat_regline_equation()
```

## SAC

```{r}
sample_size <- 4
gf_sub_abd %>% 
  filter(site %in% sample(site, size = sample_size)) %>% 
  metacommunity() %>% 
  accum_hill(levels = levels[levels <= abd_sum(., as_numeric = TRUE)]) %>% 
  autoplot() +
  scale_x_log10()
```

Portée de l'échantillon

L'estimation de la richesse à partir de la log-série de GuyaDiv:

```{r}
# Surface prise en compte
S = 4500
alpha = 250
(exp((S + alpha * log(alpha)) / alpha) - alpha) / 600 / 1E6
```
