---
title: "Appendix"
editor: visual
bibliography: references.bib
execute:
  # show code chunk output
  include: true
  # Show the code in the output
  echo: true
  # Show messages
  message: false
  # Show warnings
  warning: false
  # Cache code results
  cache: false
format: 
  html:
    toc: true
    code-fold: true
    embed-resources: true
  pdf:
    toc: true
---
```{r}
#| label: DoNotModify
#| echo: false
### Utilities for R. 
# Do not modify unless you don't use R: then, delete this chunk.
# Installation of R packages if necessary
install_packages <- function(packages) {
  invisible(
    sapply(
      packages, 
      FUN = function(package) {
        if (!package %in% installed.packages()[, 1]) {
          install.packages(package, repos = "https://cran.rstudio.com/")
        }
      }
    )
  )
}

# Basic packages
install_packages(c("knitR", "formatR", "kableExtra"))

# Chunk font size hook: allows size='small' 
# or any valid Latex font size in chunk options
def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(
  chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(
      options$size == "normalsize", 
      yes = x,
      no = paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize")
    )
  }
)
```

```{r}
#| label: Options
#| echo: false
### Customized R options for this document
# Delete this chunk if you don't use R

# Add necessary packages here
packages <- c("tidyverse", "divent", "vegan", "untb", "sads")
# Install them
install_packages(packages)

# knitr options (https://yihui.org/knitr/options/)
knitr::opts_chunk$set(
  # Code chunk automatic format if tidy is TRUE
  tidy = FALSE, 
  # Tidy code options: remove blank lines and cut lines after 50 characters
  tidy.opts = list(blank = FALSE, width.cutoff = 50),
  # Font size in PDF output
  size = "scriptsize", 
  # Select PDF figures in PDF output if PDF file exists beside PNG file
  knitr.graphics.auto_pdf = TRUE
)
# Text width of R functions output
options(width = 50)

# ggplot style
library("tidyverse")
theme_set(theme_bw())
theme_update(
  panel.background = element_rect(fill = "transparent", colour = NA),
  plot.background = element_rect(fill = "transparent", colour = NA)
)
knitr::opts_chunk$set(dev.args = list(bg = "transparent"))

# Random seed
set.seed(973)
```


## Appendix 1: Estimating $\alpha$ with R

### Point estimation

Most implementations of the calculation of $\alpha$ are limited to solving the equation

$$S(n) = \alpha \ln \left( 1 + \frac{n}{\alpha} \right),$$

where $S(n)$ is the number of species observed in a sample of size $n$.
The only data required are the total number of species and the sample size.
The fifty hectares of BCI are used in the examples below.

```{r}
library("tidyverse")
library("vegan")
data(BCI)
BCI %>% 
  colSums() ->
  BCI_50ha
```

Functions are:

-   `vegan::fisher.alpha()` that relies on `vegan::fisherfit()`. The numerical resolution uses `uniroot()`.

```{r}
#| code-fold: false
library("vegan")
fisher.alpha(BCI_50ha)
fisherfit(BCI_50ha)
```

-   `untb::fishers.alpha()`, identical to `vegan::fisherfit()`

```{r}
#| code-fold: false
library("untb")
fishers.alpha(N = sum(BCI_50ha), S = sum(BCI_50ha > 0))
```

### Likelihood maximisation

The alternative is to adjust the observed abundance distribution to the theoretical distribution of a log series, maximising its likelihood as a function of $\alpha$.

This is done by `sads::fitls()` which uses `mle2()` to maximise the likelihood of `sads::dls()` (the probability density of the logs-eries). The default starting value is the point estimate.

```{r}
#| code-fold: false
library("sads")
fitls(BCI_50ha)
```

In the case of BCI, the result is the same: the likelihood calculation gives predominant weight to the most abundant species.


## Appendix 2: Estimating $\theta$ by the abundant species distribution

@Hubbell2001 [page 293] proposes estimating $\theta$ by adjusting the rank-abundance curve to the most frequent species in the community, arguing that these species are also the most abundant in the metacommunity.

```{r}
# Theoretical rank of abundances
lseries_RAC <- function(abd, alpha) {
  rank <- vapply(
    abd, 
    function(x) {
      n <- x * log(1 + alpha / sum(abd))
      f <- stats::integrate(function(t) {exp(-t) / t}, lower = n, upper = Inf)
      fv <- f[["value"]]
      return(alpha * fv)
    }, 
    FUN.VALUE = 0
  )
  tibble(rank, abundance = abd) |>
    arrange(rank)
}
# Fit alpha by minimizing the departure of species ranks from their theoretical value in a logseries
fit_alpha <- function(abd) {
  abd_decr <- sort(abd[abd > 0], decreasing = TRUE)
  optimized <- optim(
    par = vegan::fisher.alpha(abd),
    fn = function(alpha) {
      sum(abs(seq_along(abd_decr) - lseries_RAC(abd_decr, alpha)$rank))
    }, 
    method = "L-BFGS-B",
    lower = 0
  )
  optimized$par
}

BCI_50ha %>% 
  sort(decreasing = TRUE) %>% 
  subset(. > median(.)) ->
  BCI_abundant
BCI_theta <- fit_alpha(BCI_abundant)
library("divent")
BCI_abundant %>% 
  as_abundances() %>% 
  autoplot() +
  geom_line(
    data = lseries_RAC(BCI_50ha, alpha = BCI_theta),
    aes(x = rank, y = abundance)    
  )
```

The estimate using Hubbell's method is `r round(BCI_theta)`.


# Appendix 3: Full simulation

The objective is to close the loop: using the parameters obtained from the BCI data, simulate a metacommunity and then a community of the same size as BCI.
To validate the approach, the simulated distribution should be similar to the actual one.

Estimation of BCI parameters $\theta$ and $m$ following @Etienne2005 with the untb package.

```{r}
library("untb")
if (file.exists("data/BCI_logkda.RData")) {
  # Use the saved result if available to save computation resources
  load("data/BCI_logkda.RData")
} else {
  BCI_50ha %>% 
  # name conflict with dplyr::count()
  untb::count() %>% 
  # requires pari/gp installed and in the path, or use gp_binary argument
  logkda() ->
  BCI_logkda
  # Save the result
  save(BCI_logkda, file = "data/BCI_logkda.RData")
}
BCI_50ha %>% 
  # name conflict with dplyr::count()
  untb::count() %>% 
  # Estimate theta and m
  optimal.params(log.kda = BCI_logkda) %>% 
  print() ->
  BCI_params
```

Simulation of a metacommunity: $J_m = 10^6$ (arbitrary), $\theta$ derived from BCI data.

```{r}
J_m <- 1E6
theta <- BCI_params[1]
library("divent")
the_metacommunity <- rcommunity(
  1, 
  size = J_m , 
  distribution = "lseries", 
  fisher_alpha = theta
)
```

Distribution of the local community: $J$ from BCI and $m$ estimated previously.

```{r}
J <- sum(BCI)
m <- BCI_params[2]
library("sads")
# Number of species in the local community
Svolkov(theta, m, J) %>% 
  # Must be integers for the simulation
  round() %>% 
  # Draw the species abundances
  rvolkov(theta, m, J) %>% 
  # Make it an abundances object top plot it
  as_abundances() %>% 
  # Whittaker plot
  autoplot() +
  # BCI real distribution
  geom_line(
    data = tibble(abundance = sort(BCI_50ha, decreasing = TRUE)) %>% 
      mutate(rank = seq_len(n())),
    aes(x = rank, y = abundance)
  )
```

The simulated community (red dots) corresponds fairly well to the actual distribution of BCI (black line).
