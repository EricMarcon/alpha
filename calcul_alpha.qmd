---
title: "Calcul d'Alpha de Fisher"
editor: visual
bibliography: bibliography.bib
format: 
  html:
    toc: true
    code-fold: true
    embed-resources: true
---

## Estimation ponctuelle

La plupart des implémentations du calcul de $\alpha$ se limitent à la résolution de l'équation

$$S(n) = \alpha \ln \left( 1 + \frac{n}{\alpha} \right),$$

où $S(n)$ est le nombre d'espèces observées dans un échantillon de taille $n$.
Les seules données nécessaires sont le nombre d'espèces total et la taille de l'échantillon.

```{r}
#| message: false
library("tidyverse")
library("vegan")
data(BCI)
BCI %>% 
  colSums() ->
  BCI_50ha
```

C'est le cas de:

-   `vegan::fisher.alpha()` qui s'appuie sur `vegan::fisherfit()`. La résolution numérique utilise `uniroot()`.

```{r}
library("vegan")
fisher.alpha(BCI_50ha)
fisherfit(BCI_50ha)
```

-   `untb::fishers.alpha()`, identique à `vegan::fisherfit()`

```{r}
#| message: false
library("untb")
fishers.alpha(N = sum(BCI_50ha), S = sum(BCI_50ha > 0))
```

## Maximisation de la vraisemblance

L'alternative est d'ajuster la distribution d'abondance observée à la distribution théorique d'une log-série, en maximisant sa vraisemblance en fonction de $\alpha$.

C'est le cas de : - `sads::fitls()` utilse `mle2()` pour maximiser la vraisemblance de `sads::dls()` (la densité de probabilité de la log-série).
La valeur de départ est par défaut l'estimation ponctuelle.

```{r}
#| message: false
library("sads")
fitls(BCI_50ha)
```

Dans le cas de BCI, le résultat est le même: le calcul de la vraisemblance donne un poids énorme aux espèces les plus abondantes.

## Estimation de \theta

$\theta$ est le paramètre de la log-série de la métacommunauté dont la communauté locale est issue.

Il n'y a pas de fonction facile d'accès dans R pour estimer $\theta$:

-   `untb::optimal.theta()` estime $\theta$ en assumant que $m = 1$.

```{r}
library("untb")
optimal.theta(BCI_50ha)
```

-   `untb::optimal.params()` estime $m$ et $\theta$ selon @Etienne2005. Les calculs sont extrêmement longs (et échouent avec un message d'erreur) sans utilisation d'un programme externe, pari/GP. Le code la fonction `logkda_pari_windows()` est bogué et ne permet pas d'exécuter les calculs. Une fonction corrigée est fournie ci-dessous.

- @Hubbell2001 (page 293) estime la log-série correspondant aux espèces les plus fréquentes de la communauté locale.


### Ajustement de la RAC

```{r}
# Theoretical rank of abundances
lseries_RAC <- function(abd, alpha) {
  rank <- vapply(
    abd, 
    function(x) {
      n <- x * log(1 + alpha / sum(abd))
      f <- stats::integrate(function(t) {exp(-t) / t}, lower = n, upper = Inf)
      fv <- f[["value"]]
      return(alpha * fv)
    }, 
    FUN.VALUE = 0
  )
  tibble(rank, abundance = abd) |>
    arrange(rank)
}

# Test
lseries_RAC(BCI_50ha, 50)

# Fit alpha by minimizing the departure of species ranks from their theoretical value in a logseries
fit_alpha <- function(abd) {
  abd_decr <- sort(abd[abd > 0], decreasing = TRUE)
  optimized <- optim(
    par = vegan::fisher.alpha(abd),
    fn = function(alpha) {
      sum(abs(seq_along(abd_decr) - lseries_RAC(abd_decr, alpha)$rank))
    }, 
    method = "L-BFGS-B",
    lower = 0
  )
  optimized$par
}

# Test
# Simulate a logseries with alpha = 50
library("divent")
rcommunity(1, size = 1E6, distribution = "lseries", fisher_alpha = 50) %>% 
  as.numeric() ->
  lseries_abd
# Estimate alpha
fit_alpha(lseries_abd)

# BCI
(theta <- fit_alpha(BCI_50ha))
# Ajustement sur l'ensemble de la distribution
BCI_50ha %>% 
  as_abundances() %>% 
  autoplot() +
  geom_line(
    data = lseries_RAC(BCI_50ha, alpha = theta),
    aes(x = rank, y = abundance)    
  )
```

@Hubbell2001 (page 293) propose de l'estimer en ajustant la courbe rang-abondance aux espèces les plus fréquentes de la communauté en argumentant que ces espèces sont aussi les plus abondantes de la métacommunauté.

```{r}
BCI_50ha %>% 
  sort(decreasing = TRUE) %>% 
  subset(. > median(.)) ->> 
  BCI_dominant
(theta <- fit_alpha(BCI_dominant))
# Ajustement
BCI_dominant %>% 
  as_abundances() %>% 
  autoplot() +
  geom_line(
    data = lseries_RAC(BCI_50ha, alpha = theta),
    aes(x = rank, y = abundance)    
  )
```

L'estimation par la méthode de Hubbell est `r round(theta)`.

### Etienne (2005)

La fonction `logkda_my()` remplace `logkda.pari()` sous Windows. 

```{r}
logkda_my <- function(
    a, 
    numerical = TRUE, 
    gp_binary = "C:\\Pari64-2-17-2\\gp") {

  command <- paste(gp_binary, "--version", sep = " ")
  if ((system(command, intern = FALSE, ignore.stderr = TRUE)) != 0) {
    stop("pari/gp not installed: try gp_binary='/usr/local/bin/gp' or similar")
  }
  
  pari_string <- "
  logKDAvec(abund) =
   {
     local(S,J,n,m,k,k0,k1,k2,Told,Tnew,specabund,i,j,Sdiff,cnt1,cnt2);
     abund = vecsort(abund);
     S = length(abund);
     J = sum(k = 1,S,abund[k]);
     maxabund = abund[S];
     Sdiff = 1; for(i = 2,S,if(abund[i] != abund[i - 1],Sdiff++));
     specabund = matrix(2,Sdiff,i,j,0); specabund[1,1] = abund[1]; specabund[2,1] = 1;
     cnt1 = 1; cnt2 = 1;
     for(i = 2,S,
         if(abund[i] != abund[i - 1],
            cnt1++;
            cnt2 = 1;
            specabund[1,cnt1] = abund[i];
            specabund[2,cnt1] = cnt2
            ,
            cnt2++;
            specabund[2,cnt1] = cnt2
         )
     );
     
     polyn = vector(1,i,1);
     i = 1;
     if(specabund[1,i] == 1,i++);
     Told = vector(1,i,1);
     for(n = 2,maxabund,
         Tnew = vector(n,m,(n > m) * Told[min(n-1,m)] + Told[max(1,m - 1)] * (m - 1)/(n - 1) + 0. );
         if(n == specabund[1,i],
            for(k0 = 1,specabund[2,i],
                lenpolyn2 = length(polyn) + length(Tnew) - 1;
                polyn = vector(lenpolyn2,k1,sum(k2 = max(1,k1 + 1 - length(Tnew)),min(length(polyn),k1),polyn[k2] * Tnew[k1 + 1 - k2]));
                
            );
            i++;
         );
         Told = vector(n,m,Tnew[m]);
     );
     logKDA = log(polyn);
     
     logKDA
   }
  "
  
#######################
# Fin de logkda.pari() : pas de modification
  
# logkda_pari_windows
#######################

  a <- untb::extant(as.count(a))
  count.string <- paste(as.vector(a), collapse = ",")
  pari_string <- paste(pari_string, "print(logKDAvec([", count.string, "]))")
  cat(pari_string, file = "logkda.gp")
  
# Modifie 797 de https://github.com/RobinHankin/untb/blob/master/R/untb.R
#######################
  logkda.list <- shell(paste(gp_binary, "-q", file.path(getwd(), "logkda.gp")), intern = TRUE)
  # Eliminate the last item of the list that contains a prompt
  if (is.list(logkda.list)) {
    # pari/gp returned a list
    logkda.list <- paste(logkda.list[[-length(logkda.list)]], sep = "", collapse = "")
  } else {
    # pari/gp returned a character vector
    logkda.list <- paste(logkda.list[-length(logkda.list)], sep = "", collapse = "")
  }
########################
# Fin des modifications
  if (numerical) {
    logkda.list <- (as.numeric(unlist(strsplit(gsub("\\[|\\]", "", logkda.list), ","))))
  }
  
  # shell("del logkda.gp")
  return(logkda.list)
}

# Vérification par les exemples du package
zoo <- untb::count(c(pigs = 1, dogs = 1, cats = 2, frogs = 3, bats = 5, slugs = 8))
# Calcul de log(K(D, A)) par R
l <- logkda.R(zoo, use.brob = TRUE)
# Equivalent par pari/gp
l_gp <- logkda_my(zoo)
# Calcul de theta et m
optimal.params(zoo, log.kda = l_gp)  #compare his answer of 7.047958 and 0.22635923.
```
Application à BCI

```{r}
BCI_50ha %>% 
  untb::count() %>% 
  {. ->> BCI_count} %>% 
  logkda_my() ->
  BCI_logkda
BCI_count %>% 
  optimal.params(log.kda = BCI_logkda) %>% 
  print() ->
  BCI_params
```

L'estimation selon Etienne est `r round(BCI_params[1])`.
